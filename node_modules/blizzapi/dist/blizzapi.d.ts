type Uri = string;
declare enum ConstantKey {
    REGIONS = "REGIONS",
    LOCALES = "LOCALES",
    DEFAULT_LOCALES = "DEFAULT_LOCALES",
    REGION_API_HOSTS = "REGION_API_HOSTS",
    SC2_REALMS = "SC2_REALMS",
    OAUTH_AUTHORIZE_URIS = "OAUTH_AUTHORIZE_URIS",
    OAUTH_TOKEN_URIS = "OAUTH_TOKEN_URIS",
    OAUTH_CHECK_TOKEN_URIS = "OAUTH_CHECK_TOKEN_URIS"
}
declare enum RegionNameEnum {
    us = "us",
    eu = "eu",
    kr = "kr",
    tw = "tw",
    cn = "cn"
}
declare enum RegionIdEnum {
    us = 1,
    eu = 2,
    kr = 3,
    tw = 3,
    cn = 5
}
declare enum RegionIdAsStringEnum {
    us = "1",
    eu = "2",
    kr = "3",
    tw = "3",
    cn = "5"
}
type RegionId = 1 | 2 | 3 | 5;
type RegionIdAsString = "1" | "2" | "3" | "5";
type RegionName = "us" | "eu" | "kr" | "tw" | "cn";
type RegionIdKey = string;
type RegionIdAsNumberOrString = RegionId | RegionIdAsString;
type RegionIdArray = ReadonlyArray<RegionId>;
type RegionNameArray = ReadonlyArray<RegionName>;
declare enum Locale {
    en_US = "en_US",
    es_MX = "es_MX",
    pt_BR = "pt_BR",
    en_GB = "en_GB",
    es_ES = "es_ES",
    fr_FR = "fr_FR",
    ru_RU = "ru_RU",
    de_DE = "de_DE",
    pt_PT = "pt_PT",
    it_IT = "it_IT",
    ko_KR = "ko_KR",
    zh_TW = "zh_TW",
    zh_CN = "zh_CN"
}
type LocaleArray = ReadonlyArray<Locale>;
declare enum DefaultLocaleIndex {
    us = 0,
    eu = 0,
    kr = 0,
    tw = 0,
    cn = 0
}
type DefaultLocaleIndexArray = ReadonlyArray<DefaultLocaleIndex>;
declare enum Sc2Realm {
    US = 1,
    LatAm = 2,
    Europe = 1,
    Russia = 2,
    Korea = 1,
    Taiwan = 2,
    China = 1
}
declare enum Sc2RealmAsString {
    US = "1",
    LatAm = "2",
    Europe = "1",
    Russia = "2",
    Korea = "1",
    Taiwan = "2",
    China = "1"
}
type Sc2RealmArray = ReadonlyArray<Sc2Realm>;
type Sc2RealmList = ReadonlyArray<Sc2Realm>;
type Sc2RealmAsNumberOrString = Sc2Realm | Sc2RealmAsString;
type RegionIdOrName = RegionId | RegionName;
type MaybeRegion = RegionIdOrName | undefined;
type ClientId = string;
type ClientSecret = string;
type Endpoint = string;
declare enum HttpMethod {
    GET = "GET",
    POST = "POST"
}
type ValidatorFunction = (endpoint: Endpoint) => boolean;
type AccessTokenObject = {
    access_token: string;
    token_type?: string;
    expires_in?: number;
    scope?: string;
};
type AccessToken = AccessTokenObject["access_token"] | undefined;
declare enum OAuthHost {
    us = "https://us.battle.net",
    eu = "https://eu.battle.net",
    kr = "https://apac.battle.net",
    tw = "https://apac.battle.net",
    cn = "https://www.battlenet.com.cn"
}
declare enum RegionHost {
    us = "https://us.api.blizzard.com",
    eu = "https://eu.api.blizzard.com",
    kr = "https://kr.api.blizzard.com",
    tw = "https://tw.api.blizzard.com",
    cn = "https://gateway.battlenet.com.cn"
}
declare enum OAuthEndpoint {
    authorize = "/oauth/authorize",
    token = "/oauth/token",
    checkToken = "/oauth/check_token?token="
}
declare enum ApiHeaders {
    LastModified = "last-modified"
}
declare enum ErrorCode {
    NotAuthorized = 401
}
declare enum ErrorResponseMessage {
    InvalidToken = "invalid_token",
    AccessTokenInvalid = "access_token_invalid",
    AccessTokenExpired = "access_token_invalid"
}
type InvalidAccessTokenError = {
    error: ErrorResponseMessage.AccessTokenInvalid;
};
type ExpiredAccessTokenError = {
    error: ErrorResponseMessage.AccessTokenExpired;
};
type ResponseError = InvalidAccessTokenError | ExpiredAccessTokenError;
interface AccessTokenOptions {
    validateAccessTokenOnEachQuery?: boolean;
    refreshExpiredAccessToken?: boolean;
    onAccessTokenExpired?: () => void;
    onAccessTokenRefresh?: (newAccessToken: string) => void;
}
interface QueryOptions {
    timeout?: number;
    region?: RegionIdOrName;
    headers?: object | Headers;
    params?: object | URLSearchParams;
}
interface BattleNetOptions {
    region: RegionIdOrName;
    clientId?: ClientId;
    clientSecret?: ClientSecret;
    accessToken?: AccessToken;
}
interface BattleNetQueryOptions {
    region: RegionIdOrName;
    clientId?: string;
    clientSecret?: string;
    accessToken?: AccessToken;
    endpoint: string;
    options: AccessTokenOptions & QueryOptions;
}
type RegionIdProperties<Value> = {
    readonly [key in RegionId]: Value;
};
interface BlizzAPIOptions extends BattleNetOptions, AccessTokenOptions {
}

declare abstract class OAuth2API {
    readonly clientId: ClientId | undefined;
    readonly clientSecret: ClientSecret | undefined;
    constructor(clientId: ClientId | undefined, clientSecret: ClientSecret | undefined);
}

declare abstract class BattleNetAPI extends OAuth2API {
    region: RegionIdOrName;
    accessTokenObject: AccessTokenObject | undefined;
    constructor(options: BattleNetOptions);
    getAccessToken: () => Promise<string>;
    getAccessTokenObject: () => Promise<AccessTokenObject>;
    setAccessToken(): Promise<AccessTokenObject>;
    setAccessTokenObject(): Promise<AccessTokenObject>;
    static validateAccessToken: (region: RegionIdOrName, accessToken: AccessToken) => Promise<boolean>;
    private getAccessTokenObjectFromBnet;
}

declare class BlizzAPI extends BattleNetAPI {
    readonly options: AccessTokenOptions;
    constructor(options: BlizzAPIOptions);
    query: <T = unknown>(endpoint: Endpoint, options?: QueryOptions) => Promise<ResponseError | T>;
    setRegion(region: RegionIdOrName): void;
    static getAllRegions: () => RegionIdProperties<RegionNameArray>;
    static getAllRegionIds: () => RegionIdArray;
    static getAllRegionNames: () => string[];
    static getRegionNameById: (regionId: RegionIdAsNumberOrString) => RegionNameArray;
    static validateRegionId: (regionId: RegionIdAsNumberOrString) => boolean;
    static getRegionIdByName: (regionName: RegionName) => RegionId;
    static validateRegionName: (regionName: RegionName) => boolean;
    static getAllLocales: () => RegionIdProperties<LocaleArray>;
    static getAllLocaleNames: () => string[];
    static getLocalesByRegionId: (regionId: RegionIdAsNumberOrString) => LocaleArray;
    static checkIfLocaleLooksValid: (locale: Locale) => boolean;
    static validateLocale: (locale: Locale) => boolean;
    static isLocaleValidForRegionId: (locale: Locale, regionId: RegionIdAsNumberOrString) => boolean;
    static getAllSc2Realms: () => RegionIdProperties<Sc2RealmArray>;
    static getAllAvailableSc2Realms: () => Sc2RealmList;
    static getSc2RealmsByRegionId: (regionId: RegionIdAsNumberOrString) => Sc2RealmList;
    static checkIfSc2RealmLooksValid: (sc2Realm: Sc2RealmAsNumberOrString) => boolean;
    static validateSc2Realm: (sc2Realm: Sc2RealmAsNumberOrString) => boolean;
    static isSc2RealmValidForRegionId: (sc2Realm: Sc2RealmAsNumberOrString, regionId: RegionIdAsNumberOrString) => boolean;
    static getDefaultLocaleNameForRegionId: (regionId: RegionIdAsNumberOrString) => Locale;
    static getAllDefaultLocaleNames: () => RegionIdProperties<Locale>;
}

export { AccessToken, AccessTokenObject, AccessTokenOptions, ApiHeaders, BattleNetOptions, BattleNetQueryOptions, BlizzAPI, BlizzAPIOptions, ClientId, ClientSecret, ConstantKey, DefaultLocaleIndex, DefaultLocaleIndexArray, Endpoint, ErrorCode, ErrorResponseMessage, ExpiredAccessTokenError, HttpMethod, InvalidAccessTokenError, Locale, LocaleArray, MaybeRegion, OAuthEndpoint, OAuthHost, QueryOptions, RegionHost, RegionId, RegionIdArray, RegionIdAsNumberOrString, RegionIdAsString, RegionIdAsStringEnum, RegionIdEnum, RegionIdKey, RegionIdOrName, RegionIdProperties, RegionName, RegionNameArray, RegionNameEnum, ResponseError, Sc2Realm, Sc2RealmArray, Sc2RealmAsNumberOrString, Sc2RealmAsString, Sc2RealmList, Uri, ValidatorFunction };
